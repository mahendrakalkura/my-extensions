// Simplified DOM to canvas implementation
window.html2canvas = function(element, options) {
  return new Promise((resolve) => {
    const rect = element.getBoundingClientRect();
    const canvas = document.createElement('canvas');
    const scale = window.devicePixelRatio || 1;

    canvas.width = rect.width * scale;
    canvas.height = rect.height * scale;
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';

    const ctx = canvas.getContext('2d');
    ctx.scale(scale, scale);

    // Use foreignObject and SVG to render DOM element
    const data = `
      <svg xmlns="http://www.w3.org/2000/svg" width="${rect.width}" height="${rect.height}">
        <foreignObject width="100%" height="100%">
          <div xmlns="http://www.w3.org/1999/xhtml" style="font-size: 16px;">
            ${element.outerHTML}
          </div>
        </foreignObject>
      </svg>
    `;

    const img = new Image();
    const blob = new Blob([data], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);

    img.onload = () => {
      ctx.drawImage(img, 0, 0);
      URL.revokeObjectURL(url);
      resolve(canvas);
    };

    img.onerror = () => {
      // Fallback: capture styles and render manually
      const styles = window.getComputedStyle(element);
      ctx.fillStyle = styles.backgroundColor || '#ffffff';
      ctx.fillRect(0, 0, rect.width, rect.height);
      ctx.fillStyle = styles.color || '#000000';
      ctx.font = styles.font || '16px Arial';
      ctx.fillText(element.textContent.substring(0, 100), 10, 30);
      URL.revokeObjectURL(url);
      resolve(canvas);
    };

    img.src = url;
  });
};
